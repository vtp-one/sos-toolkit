## SOS-Tool
Tool objects are python functions that are registered for use with the SOS-Toolkit to be used by Actions. 
Custom Tools can also be dynamically defined and loaded by a system during runtime.

The schema used to define tools is intended to make them usable for function calling with an LLM, and most likely will be modified in the future.

Tools are registered using their parent directory as a namespace, and the name of the function as the specific tool:
```
tool: namespace.tool_name
```

If a tool function: `test_tool` is in a file called `test.py` which is in a folder `test_namespace`:
```
[ test_namespace/test.py ]
@sos_tool
def test_tool():
    """A Test Tool"""
    return True
```
This tool will be registered as:
```
test_namespace.test_tool
```

We want to keep these names easy and specific to minimize the complexity of using them for an LLM.

Attempting to overwrite a tool will cause an error unless the tool is manually registered using an `overwrite` parameter. This functionality is difficult to use currently due to the nature of using the `@sos_tool` decorator, this will be changed in the future. The important fact is that you can not easily overwrite already named tools in a namespace, trying to do so will result in an error.

Builtin tools are stored in the SOS-Toolkit source folder: tool.

For more information about included tools: [SOS-Tool](../06_reference/01_tools.md)

Currently these are organized in 6 namespaces: 
 - `cli`
 - `context`
 - `docker`
 - `filesystem`
 - `git`
 - `terminal`

Each folder contains python files, and each file contains functions that are registered using the `@sos_tool` decorator.

The python functions used for the tools require all parameters for the function to be keyword arguments that include annotations using a combination of the Annotated typing object and the pydantic Field object. 
The Annotated object is used to include the type specification for the input for the parameter. The Field object is used to provide a description for the parameter. 
Parameters can include a default value after this definition.

Tool objects require a doc-string at the start of the function using triple-quoted strings. 
This string should be used to provide a simple description of what the tool does.

By annotating the functions in this way, we can maximize the useful information provided to an LLM.

Tool's can use a `__CTX__` parameter as their first keyword argument to indicate that they require an SOSContext object passed to them. 
When run as an Action, the SOS-Toolkit will attempt to inject the current Context object as this `__CTX__` parameter.

Tool's can also include a `__RESULT__` parameter as either their second keyword argument if `__CTX__` is used, or as the first keyword argument otherwise. This indicates that the tool expects a `__RESULT__` object provided by a previous tool invocation. 
This functionality can only be used if a tool is called from an ActionRepo list where a previous tool has already generated a `__RESULT__`. 
If a Result object isn't available, this will raise an exception.

When used from an Action, a `context_map` will pull values from the context and map them to the keyword for the tool arguments. 
An Action may define a params object which will directly provide values for the keywords. 
Keywords generated by a context_map will take precedence over values provided by params.

In the python function, the tool can execute any python code. 
This can include using imported modules from the file that the tool is defined in.
A tool can also directly interact with the SOSContext object if it included the `__CTX__` object as a keyword.

Tool's can return any value, but returning a dictionary is prefered. 
When a tool is run from an Action, if a returned object is not a dictionary, it will be placed in one: `{"result":RETURNED_OBJECT}`. 
This is to enable the usage of `result_map` from an Action definition. 

The Action's `result_map` will operate on this Result dictionary to map data back into the SOSContext.

After running the `result_map`, the entire Result object will be placed into the special context field `__RESULT__` for use by subsequent actions. 
This functionality is intended to allow tools to pass objects that can not be saved to a YAML file.
The `__RESULT__` object will be deleted after running through a complete ActionRepo list.


## Example
For an example of a tool, we can look at a terminal tool called `print_context`. 
It is found in the `tool/terminal/print.py` file. 
Using this folder structure, the namespace for the tool is `terminal` and the function is defined as `print_context`. 
Putting these together, the tool can be used in an Action with: `terminal.print_context`
```
@sos_tool
def print_context(
    __CTX__: Annotated[Optional[SOSContext], Field(description="SOSContext Object")],
    ctx_target: Annotated[Optional[str], Field(description="Target Object to Print")] = None,
    horizontal_rule: Annotated[bool, Field(description="If wrap the output in horizontal rules")] = False
):
    """Print the current context to the terminal"""
    rich.print({"terminal.print_context":
            {
            "ctx_target":ctx_target
            }
        })

    if horizontal_rule:
        rich.print(rich.rule.Rule())

    if ctx_target is not None:
        rich.print(__CTX__.get(ctx_target, None))

    else:
        __CTX__.print()

    if horizontal_rule:
        rich.print(rich.rule.Rule())

    return True
```
The purpose of this tool is to print output to the terminal. 
It requires a `__CTX__` object in order to run. 
It takes two optional parameters, `ctx_target` and `horizontal_rule`. 
The valid types, descriptions, and default values are provided in the definition. 

The function of the tool is straight-forward: 
 - If it is provided a `ctx_target`, it attempts to get that target from the `__CTX__` object and print it
 - If it isn't provided a `ctx_target`, it prints the entire context. 
 - The `horizontal_rule` parameter provides a way to increase visibility of this specific print object by printing horizontal bars
 - On completion, the tool returns True.


An action that uses this tool:
```
test_print:
    tool: terminal.print_context
    params:
      horizontal_rule: True
```


## Tool Plugins
Tools can provide access to any python code you want, and as already mentioned, they can be dynamically added by systems. 

Doing this utilizes a tool: `context.tool_module` - which is defined in the `tool/context/tool.py` file.
```
@sos_tool
def tool_module(
    target: Annotated[str, Field(description="Target module to load tools")],
    overwrite: Annotated[Optional[bool], Field(description="If overwrite preexisting tool")] = False
):
[ TOOL CODE ]
```
The tool expects a target which is the folder-path to the parent directory for the python files that contain tools. 
The function iterates through the files in the folder and loads any functions from those files decorated with `@sos_tool` into the SOS-Toolkit.
The loaded tools will utilize the namespace that is the last part of the target path:
```
target = /folder/path/target_namespace
```

Using this tool can be done during the hook: `on_context_load`. 
By using this tool as a hook, you can automatically add tools for your systems whenever the context is loaded. 
The loaded tools will then be useable by any Action that is being run.
